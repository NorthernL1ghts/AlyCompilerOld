#include <codegen.h>
#include <environment.h>
#include <error.h>
#include <parser.h>

#include <stdio.h>
#include <string.h>

// TODO: Actually name the compiler and the language, this name may change.
//		 Add version number?
const char* codegen_header = "This file was generated by the AlyCompiler";

unsigned int fwrite_line(char* bytestring, FILE* file) {
	size_t length = strlen(bytestring);
	unsigned int status = fwrite(bytestring, 1, length, file);
	if (!status != 0) {}
	return fwrite("\n", 1, 1, file);
}

// NOTE: This method does the exact same but for bytes/string rather than lines.
// TODO: Move to some kind of new file, either helper or Codegen related.
unsigned int fwrite_bytes(char* bytestring, FILE* file) {
	size_t length = strlen(bytestring);
	return fwrite(bytestring, 1, length, file);
}

Error codegen_program_x86_64_att_asm(ParsingContext* context, Node* program) {
	Error err = ok;
	if (!program || program->type != NODE_TYPE_PROGRAM) {
		ERROR_PREP(err, ERROR_ARGUMENTS, "codegen_program() requires program!");
		return err;
	}

	FILE* code = fopen("code.S", "wb");
	if (!code) {
		ERROR_PREP(err, ERROR_GENERIC, "codegen_program() could not open code file");
		return err;
	}

	fwrite_line((char*)codegen_header, code);

	// TODO: Generate code for program :^>

	// TODO: Allocate `.space` for all global variable declarations.

	Node* expression = program->children;
	Node* tmpnode1 = node_allocate();
	while (expression) {
		switch (expression->type) {
		default:
			break;
		case NODE_TYPE_VARIABLE_DECLARATION:
			// TODO: Get size of type, generate `<identifier>: .space <size>`. 
			// Keep track of identifier somehow.

			// NOTE: 'tmpnode' is used because variable allocation inside a switch case 
			// requires explicit scoping with {} in C.
			// Retrieves the type symbol ID for a variable from the variables context 
			// using its associated symbol ID.
			environment_get(*context->variables, expression->children, tmpnode1);
			// Get type information of type from type context usign type symbol ID.
			environment_get(*context->types, tmpnode1, tmpnode1);

			fwrite_bytes("", code);

			print_node(tmpnode1, 0);
			// TODO: Handle nested scopes (stack-based variables).
			break;
		}
		expression = expression->next_child;
	}

	fclose(code);
	return ok;
}

Error codegen_program(CodegenOutputFormat format, ParsingContext* context, Node* program) {
	if (!context) {
		ERROR_CREATE(err, ERROR_ARGUMENTS, "codegen_program() must be passed a non-NULL context!");
		return err;
	}
	switch (format) {
	case OUTPUT_FMT_DEFAULT:
	case OUTPUT_FMT_x86_64_AT_T_ASM:
		return codegen_program_x86_64_att_asm(context, program);
	}
	return ok;
}