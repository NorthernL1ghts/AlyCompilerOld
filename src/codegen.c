/*
 * Copyright (c) 2025 NorthernL1ghts. All rights reserved.
 *
 * This file is part of the AlyCompiler.
 * Unauthorized copying, modification, or distribution of this file,
 * via any medium, is strictly prohibited except as permitted under
 * the terms outlined in the LICENSE file.
 *
 * For licensing details, contributions, or inquiries, refer to LICENSE
 * or contact:
 * NorthernL1ghts Software Division
 */

#include <codegen.h>
#include <environment.h>
#include <error.h>
#include <parser.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

 // TODO: Actually name the compiler and the language, this name may change.
 // TODO: Add version number?
const char* codegen_header = "This file was generated by the AlyCompiler";

//============================================================== BEG FILE HELPERS
// NOTE: Writes a string followed by a newline to the specified file.
// Takes: A `char*` bytestring and a `FILE*` handle.
// Returns: An `Error` indicating success or failure.
Error fwrite_line(char* bytestring, FILE* file) {
    ERROR_CREATE(err, ERROR_GENERIC, "fwrite_line(): Could not write line");
    size_t length = strlen(bytestring);
    size_t bytes_written = fwrite(bytestring, 1, length, file);
    if (bytes_written != length) { return err; }
    bytes_written = fwrite("\n", 1, 1, file);
    if (bytes_written != length) { return err; }
    return ok;
}

// NOTE: Writes raw bytes (as a string) to a file.
// Takes: A `char*` bytestring and a `FILE*` handle.
// Returns: An `Error` if the write fails.
Error fwrite_bytes(char* bytestring, FILE* file) {
    ERROR_CREATE(err, ERROR_GENERIC, "fwrite_bytes(): Could not write bytes");
    if (!file) { return err; }
    size_t length = strlen(bytestring);
    size_t bytes_written = fwrite(bytestring, 1, length, file);
    if (bytes_written != length) { return err; }
    return ok;
}

// NOTE: Converts an integer to a string and writes it to a file.
// Takes: A `long long` integer and a `FILE*` handle.
// Returns: An `Error` based on write success.
#define FWRITE_INT_STRING_BUFFER_SIZE 21
static char number[FWRITE_INT_STRING_BUFFER_SIZE];
Error fwrite_integer(long long integer, FILE* file) {
    ERROR_CREATE(err, ERROR_GENERIC, "fwrite_integer(): Could not write integer");
    if (!file) { return err; }
    sprintf(number, "%lld", integer);
    err = fwrite_bytes(number, file);
    return ok;
}
//============================================================== END FILE HELPERS

//============================================================== BEG x86_64 AT&T ASM
Error codegen_program_x86_64_att_asm_data_section(ParsingContext* context, FILE* code) {
    Error err = ok;

    // TODO: Deal with initialization of global variables somehow. Not really sure how to do this yet.
    fwrite_line(".section .data", code);
    if (err.type) { return err; }

    Node* type_info = node_allocate();
    Binding* it = context->variables->bind;
    while (it) {
        Node* var_id = it->id;
        Node* type_id = it->value;
        it = it->next;

        // Get type information of type from type context usign type symbol ID.
        environment_get(*context->types, type_id, type_info);

        // Write identifier corresponding to variable (pass through literally, for now).
        err = fwrite_bytes(var_id->value.symbol, code);
        if (err.type) { return err; }
        err = fwrite_bytes(": .space ", code);
        if (err.type) { return err; }
        err = fwrite_integer(type_info->children->value.integer, code);
        if (err.type) { return err; }
        err = fwrite_bytes("\n", code);
        if (err.type) { return err; }
    }
    free(type_info);
    return err;
}

// Just forward declaration for the moment whilst we test, this means fix the recursion?
Error codegen_function_x86_64_att_asm_mswin(ParsingContext* context, char* name, Node* function, FILE* code);

// If TOP_LEVEL is non-zero, it is assumed that expression are in top level of program
Error codegen_expression_list_x86_64_att_asm_mswin(ParsingContext* context, Node* expression, FILE* code) {
    Error err = ok;
    Node* tmpnode = node_allocate();
    size_t tmpcount;
    const size_t lambda_symbol_size = 8;
    char lambda_symbol[8];
    for (size_t i = 0; i < lambda_symbol_size; ++i) {
        // Randomly assign a ASCII name to undefined functions such as lambda
        lambda_symbol[i] = (rand() % 26) + 97;
    }
    while (expression) {
        tmpcount = 0;
        switch (expression->type) {
        default:
            break;
        case NODE_TYPE_FUNCTION:
            // Handling a function here means a lambda should be generated, I think.
            // TODO: Generate name from some sort of hashing algorithm or something.
            err = codegen_function_x86_64_att_asm_mswin(context, lambda_symbol, expression, code);
            // If we were to keep track of the name of this function, we could 
            // then properly fill in the jump memory label further on in the program.
            if (err.type) { return err; }
            break;
        case NODE_TYPE_FUNCTION_CALL:
            // TODO: Actually codegen argument expressions.
            tmpnode = expression->children->next_child->children;
            while (tmpnode) {
                switch (tmpcount) {
                default:
                    printf("TODO: Codegen stack allocated arguments\n");
                    // stack stuff
                    break;
                case 0:
                    fwrite_bytes("mov $", code);
                    // TODO: FIXME: This assumes integer type, and is bad bad bad!!!
                    fwrite_integer(tmpnode->value.integer, code);
                    fwrite_line(", %rcx", code);
                    break;
                case 1:
                    fwrite_bytes("mov $", code);
                    // TODO: FIXME: This assumes integer type, and is bad bad bad!!!
                    fwrite_integer(tmpnode->value.integer, code);
                    fwrite_line(", %rdx", code);
                    break;
                case 2:
                    fwrite_bytes("mov $", code);
                    // TODO: FIXME: This assumes integer type, and is bad bad bad!!!
                    fwrite_integer(tmpnode->value.integer, code);
                    fwrite_line(", %r8", code);
                    break;
                case 3:
                    fwrite_bytes("mov $", code);
                    // TODO: FIXME: This assumes integer type, and is bad bad bad!!!
                    fwrite_integer(tmpnode->value.integer, code);
                    fwrite_line(", %r9", code);
                    break;
                }
                tmpnode = tmpnode->next_child;
                tmpcount += 1;
            }
            fwrite_bytes("call ", code);
            fwrite_line(expression->children->value.symbol, code);
            break;
        case NODE_TYPE_VARIABLE_REASSIGNMENT:
            // TODO: Find variable binding and keep track of which contexxt it is found in.
            //       If context is top-level, use global variable access. otherwise local.

            // TODO: Evaluate reassignment expression and get return value,
            //       that way we can actually use.

            if (!context->parent) {
                fwrite_bytes("lea ", code);
                fwrite_bytes(expression->children->value.symbol, code);
                fwrite_line("(%rip), %rax", code);
                fwrite_bytes("movq $", code);
                // TODO: FIXME: This assumes integer type, and is bad bad bad!!!
                fwrite_integer(expression->children->next_child->value.integer, code);
                fwrite_line(", (%rax)", code);
            }
            else {
                // Get index of argument within function parameter list

                // Use index of argument to write to proper address/register
            }
            break;
        }

        expression = expression->next_child;
    }
    free(tmpnode);

    return ok;
}

Error codegen_function_x86_64_att_asm_mswin(ParsingContext* context, char* name, Node* function, FILE* code) {
    Node* parameter = function->children;
    // Nested function execution protection
    fwrite_bytes("jmp after", code);
    fwrite_line(name, code);

    // Function begin memory symbol
    fwrite_bytes(name, code);
    fwrite_line(":", code);

    // Function header
    fwrite_line("push %rbp", code);
    fwrite_line("mov %rsp, %rbp", code);
    fwrite_line("sub $32, %rsp", code);

    // Function body
    context = parse_context_create(context);
    codegen_expression_list_x86_64_att_asm_mswin(context, function->next_child->next_child->children, code);
    // TODO: Free context
    context = context->parent;

    // Function footer
    fwrite_line("add $32, %rsp", code);
    fwrite_line("pop %rbp", code);
    fwrite_line("ret", code);

    // Nested function execution jump label
    fwrite_bytes("after", code);
    fwrite_bytes(name, code);
    fwrite_line(":", code);

    return ok;
}

/// Emit x86_64 AT&T Assembly with MS Window's function calling convention.
/// Arguments passed in: RCX, RDX, R8, R9 -> stack
Error codegen_program_x86_64_att_asm_mswin(ParsingContext* context, Node* program) {
    Error err = ok;
    if (!program || program->type != NODE_TYPE_PROGRAM) {
        ERROR_PREP(err, ERROR_ARGUMENTS, "codegen_program() requires program!");
        return err;
    }

    FILE* code = fopen("code.S", "wb");
    if (!code) {
        ERROR_PREP(err, ERROR_GENERIC, "codegen_program() could not open code file");
        return err;
    }

    err = fwrite_bytes(";;#; ", code);
    if (err.type) { return err; }
    fwrite_line((char*)codegen_header, code);
    if (err.type) { return err; }

    // Generate global variables
    codegen_program_x86_64_att_asm_data_section(context, code);

    fwrite_line(".section .text", code);

    // Generate global functions
    Binding* function_it = context->functions->bind;
    while (function_it) {
        Node* function_id = function_it->id;
        Node* function = function_it->value;
        function_it = function_it->next;

        err = codegen_function_x86_64_att_asm_mswin(context, function_id->value.symbol, function, code);
    }

    // Top level program header
    fwrite_line(".global _start", code);
    fwrite_line("_start:", code);
    fwrite_line("push %rbp", code);
    fwrite_line("mov %rsp, %rbp", code);
    fwrite_line("sub $32, %rsp", code);

    // TODO: At some point we have to initialize global variables.

    // Program body
    codegen_expression_list_x86_64_att_asm_mswin(context, program->children, code);

    // Top level program footer
    fwrite_line("add $32, %rsp", code);
    fwrite_line("pop %rbp", code);
    fwrite_line("ret", code);

    fclose(code);
    return ok;
}
//============================================================== END x86_64 AT&T ASM

Error codegen_program(CodegenOutputFormat format, ParsingContext* context, Node* program) {
    if (!context) {
        ERROR_CREATE(err, ERROR_ARGUMENTS, "codegen_program() must be passed a non-NULL context!");
        return err;
    }
    switch (format) {
    case OUTPUT_FMT_DEFAULT:
    case OUTPUT_FMT_x86_64_AT_T_ASM:
        return codegen_program_x86_64_att_asm_mswin(context, program);
    }
    return ok;
}