/*
 * Copyright (c) 2025 NorthernL1ghts
 */

/*
 * SHA HASH: c0c76024dad6ee88c3778ff35bad9ee3b0f656e83a463089ca5ef636ce70dad9
 * Filename: src/codegen.c
 * Updated: 2025-05-01, 13:13:40
*/
#include <environment.h>
#include <error.h>
#include <parser.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// TODO: Actually name the compiler and the language, this name may change.
//		 Add version number?
const char* codegen_header = "This file was generated by the AlyCompiler";

//============================================================== BEG FILE HELPERS
Error fwrite_line(char* bytestring, FILE* file) {
    ERROR_CREATE(err, ERROR_GENERIC, "fwrite_line(): Could not write line");
    size_t length = strlen(bytestring);
    size_t bytes_written = fwrite(bytestring, 1, length, file);
    if (bytes_written != length) { return err; }
    bytes_written = fwrite("\n", 1, 1, file);
    if (bytes_written != length) { return err; }
    return ok;
}

// NOTE: This method does the exact same but for bytes/string rather than lines.
// TODO: Move to some kind of new file, either helper or Codegen related.
Error fwrite_bytes(char* bytestring, FILE* file) {
    ERROR_CREATE(err, ERROR_GENERIC, "fwrite_bytes(): Could not write bytes");
    if (!file) { return err; }
    size_t length = strlen(bytestring);
    size_t bytes_written = fwrite(bytestring, 1, length, file);
    if (bytes_written != length) { return err; }
    return ok;
}

// NOTE: We only actually need 19 as long long is 2^63 or 8 bytes;
// However, allocation need 1 so we have extra in buffer.
#define FWRITE_INT_STRING_BUFFER_SIZE 21
static char number[FWRITE_INT_STRING_BUFFER_SIZE];
Error fwrite_integer(long long integer, FILE* file) {
    ERROR_CREATE(err, ERROR_GENERIC, "fwrite_integer(): Could not write integer");
    if (!file) { return err; }
    sprintf(number, "%lld", integer);
    err = fwrite_bytes(number, file);
    return ok;
}

//============================================================== END FILE HELPERS

//============================================================== BEG x86_64 AT&T ASM
Error codegen_program_x86_64_att_asm_data_section(ParsingContext* context, FILE* code) {
    Error err = ok;

    // TODO: Deal with initialization of global variables somehow. Not really sure how to do this yet.
    fwrite_line(".section .data", code);
    if (err.type) { return err; }

    Node* type_info = node_allocate();
    Binding* it = context->variables->bind;
    while (it) {
        Node* var_id = it->id;
        Node* type_id = it->value;
        it = it->next;

        // Get type information of type from type context usign type symbol ID.
        environment_get(*context->types, type_id, type_info);

        // Write identifier corresponding to variable
        // (pass through literally, for now).
        err = fwrite_bytes(var_id->value.symbol, code);
        if (err.type) { return err; }
        err = fwrite_bytes(": .space ", code);
        if (err.type) { return err; }
        err = fwrite_integer(type_info->children->value.integer, code);
        if (err.type) { return err; }
        err = fwrite_bytes("\n", code);
        if (err.type) { return err; }
    }
    free(type_info);
    return err;
}

Error codegen_program_x86_64_att_asm(ParsingContext* context, Node* program) {
    Error err = ok;
    if (!program || program->type != NODE_TYPE_PROGRAM) {
        ERROR_PREP(err, ERROR_ARGUMENTS, "codegen_program() requires program!");
        return err;
    }

    FILE* code = fopen("code.S", "wb");
    if (!code) {
        ERROR_PREP(err, ERROR_GENERIC, "codegen_program() could not open code file");
        return err;
    }

    err = fwrite_bytes(";#; ", code);
    if (err.type) { return err; }
    fwrite_line((char*)codegen_header, code);
    if (err.type) { return err; }

    codegen_program_x86_64_att_asm_data_section(context, code);

    fwrite_line(".section .text", code);

    // Top level program header
    fwrite_line("_start:", code);
    fwrite_line("push %rbp", code); // Preserve base pointer mostly redundant, we don't really need to do this.
    fwrite_line("mov %rsp, %rbp", code);
    //fwrite_line("sub $32, %rsp", code); // Again, this isn't really needed but may keep 64 byte alignment.

    Node* expression = program->children;
    Node* tmpnode1 = node_allocate();
    while (expression) {
        switch (expression->type) {
        default:
            break;
        case NODE_TYPE_VARIABLE_REASSIGNMENT:
            // TODO: Evaluate reassignment expression and get return value
            //       So that we can actually use.
            fwrite_bytes("lea ", code);
            fwrite_bytes(expression->children->value.symbol, code);
            fwrite_line("(%rip), %rax", code);
            fwrite_bytes("movq $", code);
            // TODO: FIXME: This assumes integer type, and is bad bad bad!!!
            fwrite_integer(expression->children->next_child->value.integer, code);
            fwrite_line(", (%rax)", code);

            // RAX : 0xffffffffffffffffffffffff -> memory address and write at that address.
            // *RAX = 42;
            // *RAX = *RAX;
            // ...
            break;
        }
        expression = expression->next_child;
    }

    // Top level program footer
    fwrite_line("add $32, %rsp", code);
    fwrite_line("movq (%rax), %rax", code);
    fwrite_line("pop %rbp", code);
    fwrite_line("ret", code);

    fclose(code);
    return ok;
}
//============================================================== END x86_64 AT&T ASM

Error codegen_program(CodegenOutputFormat format, ParsingContext* context, Node* program) {
    if (!context) {
        ERROR_CREATE(err, ERROR_ARGUMENTS, "codegen_program() must be passed a non-NULL context!");
        return err;
    }
    switch (format) {
    case OUTPUT_FMT_DEFAULT:
    case OUTPUT_FMT_x86_64_AT_T_ASM:
        return codegen_program_x86_64_att_asm(context, program);
    }
    return ok;
}