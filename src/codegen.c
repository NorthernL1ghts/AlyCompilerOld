/*
 * Copyright (c) 2025 NorthernL1ghts
 */

#include <codegen.h>
#include <environment.h>
#include <error.h>
#include <parser.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

 // TODO: Actually name the compiler and the language, this name may change.
 // TODO: Add version number?
const char* codegen_header = "This file was generated by the AlyCompiler";

//============================================================== BEG FILE HELPERS
// NOTE: Writes a string followed by a newline to the specified file.
// Takes: A `char*` bytestring and a `FILE*` handle.
// Returns: An `Error` indicating success or failure.
Error fwrite_line(char* bytestring, FILE* file) {
    ERROR_CREATE(err, ERROR_GENERIC, "fwrite_line(): Could not write line");
    size_t length = strlen(bytestring);
    size_t bytes_written = fwrite(bytestring, 1, length, file);
    if (bytes_written != length) { return err; }
    bytes_written = fwrite("\n", 1, 1, file);
    if (bytes_written != length) { return err; }
    return ok;
}

// NOTE: Writes raw bytes (as a string) to a file.
// Takes: A `char*` bytestring and a `FILE*` handle.
// Returns: An `Error` if the write fails.
Error fwrite_bytes(char* bytestring, FILE* file) {
    ERROR_CREATE(err, ERROR_GENERIC, "fwrite_bytes(): Could not write bytes");
    if (!file) { return err; }
    size_t length = strlen(bytestring);
    size_t bytes_written = fwrite(bytestring, 1, length, file);
    if (bytes_written != length) { return err; }
    return ok;
}

// NOTE: Converts an integer to a string and writes it to a file.
// Takes: A `long long` integer and a `FILE*` handle.
// Returns: An `Error` based on write success.
#define FWRITE_INT_STRING_BUFFER_SIZE 21
static char number[FWRITE_INT_STRING_BUFFER_SIZE];
Error fwrite_integer(long long integer, FILE* file) {
    ERROR_CREATE(err, ERROR_GENERIC, "fwrite_integer(): Could not write integer");
    if (!file) { return err; }
    sprintf(number, "%lld", integer);
    err = fwrite_bytes(number, file);
    return ok;
}
//============================================================== END FILE HELPERS

//============================================================== BEG x86_64 AT&T ASM
Error codegen_program_x86_64_att_asm_data_section(ParsingContext* context, FILE* code) {
    Error err = ok;

    // TODO: Deal with initialization of global variables somehow. Not really sure how to do this yet.
    fwrite_line(".section .data", code);
    if (err.type) { return err; }

    Node* type_info = node_allocate();
    Binding* it = context->variables->bind;
    while (it) {
        Node* var_id = it->id;
        Node* type_id = it->value;
        it = it->next;

        // Get type information of type from type context usign type symbol ID.
        environment_get(*context->types, type_id, type_info);

        // Write identifier corresponding to variable
        // (pass through literally, for now).
        err = fwrite_bytes(var_id->value.symbol, code);
        if (err.type) { return err; }
        err = fwrite_bytes(": .space ", code);
        if (err.type) { return err; }
        err = fwrite_integer(type_info->children->value.integer, code);
        if (err.type) { return err; }
        err = fwrite_bytes("\n", code);
        if (err.type) { return err; }
    }
    free(type_info);
    return err;
}

/// Emit x86_64 AT&T Assembly with MS Window's function calling convention.
/// Arguments passed in: RCX, RDX, R8, R9 -> stack
Error codegen_program_x86_64_att_asm_mswin(ParsingContext* context, Node* program) {
    Error err = ok;
    if (!program || program->type != NODE_TYPE_PROGRAM) {
        ERROR_PREP(err, ERROR_ARGUMENTS, "codegen_program() requires program!");
        return err;
    }

    FILE* code = fopen("code.S", "wb");
    if (!code) {
        ERROR_PREP(err, ERROR_GENERIC, "codegen_program() could not open code file");
        return err;
    }

    err = fwrite_bytes(";;#; ", code);
    if (err.type) { return err; }
    fwrite_line((char*)codegen_header, code);
    if (err.type) { return err; }

    codegen_program_x86_64_att_asm_data_section(context, code);

    fwrite_line(".section .text", code);

    // Top level program header
    fwrite_line("_start:", code);
    fwrite_line("push %rbp", code); // Preserve base pointer mostly redundant, we don't really need to do this.
    fwrite_line("mov %rsp, %rbp", code);
    fwrite_line("sub $32, %rsp", code); // Again, this isn't really needed but may keep 64 byte alignment.

    Node* expression = program->children;
    Node* tmpnode = node_allocate();
    size_t tmpcount;
    while (expression) {
        tmpcount = 0;
        switch (expression->type) {
        default:
            break;
        case NODE_TYPE_FUNCTION_CALL:
            // TODO: Actually codegen argument expressiobs.
            tmpnode = expression->children->next_child->children;
            while (tmpnode) {
                switch (tmpcount) {
                default:
                    printf("TODO: Codegen stack allocated arguments\n");
                    // stack stuff
                    break;
                case 0:
                    fwrite_bytes("mov $", code);
                    // TODO: FIXME: This assumes integer type, and is bad bad bad!!!
                    fwrite_integer(tmpnode->value.integer, code);
                    fwrite_line(", %rcx", code);
                    break;
                case 1:
                    fwrite_bytes("mov $", code);
                    // TODO: FIXME: This assumes integer type, and is bad bad bad!!!
                    fwrite_integer(tmpnode->value.integer, code);
                    fwrite_line(", %rdx", code);
                    break;
                case 2:
                    fwrite_bytes("mov $", code);
                    // TODO: FIXME: This assumes integer type, and is bad bad bad!!!
                    fwrite_integer(tmpnode->value.integer, code);
                    fwrite_line(", %r8", code);
                    break;
                case 3:
                    fwrite_bytes("mov $", code);
                    // TODO: FIXME: This assumes integer type, and is bad bad bad!!!
                    fwrite_integer(tmpnode->value.integer, code);
                    fwrite_line(", %r9", code);
                    break;
                }
                tmpnode = tmpnode->next_child;
                tmpcount += 1;
            }
            fwrite_bytes("call ", code);
            fwrite_line(expression->children->value.symbol, code);
            break;
        case NODE_TYPE_VARIABLE_REASSIGNMENT:
            // TODO: Evaluate reassignment expression and get return value
            //       That we can actually use.
            fwrite_bytes("lea ", code);
            fwrite_bytes(expression->children->value.symbol, code);
            fwrite_line("(%rip), %rax", code);
            fwrite_bytes("movq $", code);
            // TODO: FIXME: This assumes integer type, and is bad bad bad!!!
            fwrite_integer(expression->children->next_child->value.integer, code);
            fwrite_line(", (%rax)", code);
            break;
        }
        expression = expression->next_child;
    }
    free(tmpnode);

    // Top level program footer
    fwrite_line("add $32, %rsp", code);
    fwrite_line("movq (%rax), %rax", code);
    fwrite_line("pop %rbp", code);
    fwrite_line("ret", code);

    fclose(code);
    return ok;
}
//============================================================== END x86_64 AT&T ASM

Error codegen_program(CodegenOutputFormat format, ParsingContext* context, Node* program) {
    if (!context) {
        ERROR_CREATE(err, ERROR_ARGUMENTS, "codegen_program() must be passed a non-NULL context!");
        return err;
    }
    switch (format) {
    case OUTPUT_FMT_DEFAULT:
    case OUTPUT_FMT_x86_64_AT_T_ASM:
        return codegen_program_x86_64_att_asm_mswin(context, program);
    }
    return ok;
}